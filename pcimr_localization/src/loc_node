#!/usr/bin/env python3

import rospy
import numpy as np
import time
import random
from threading import Lock

from std_msgs.msg import String
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Point, Pose, Quaternion
from nav_msgs.msg import OccupancyGrid
from visualization_msgs.msg import Marker

class Localization_Node:
	"""
	A node, capsuling the functionality from the simple robot simulator.
	"""

	def __init__(self):
		#robot_variable
		
		#remember last pos
		self.last_pos = None
		self.pos = None
		
		# notices whether it received map earlier
		self.receive_map_data=0
		
		#input probabilities
		input_string = rospy.get_param('~robot_move_probabilities')
		
		#create list of float
		input_string = input_string[1:len(input_string)-2]
		self.action_prob=[]
		for  item in input_string.split(', '):
			self.action_prob.append(float(item))
		
		#sensing probabilities
		self.sensing_prob=[0.8,0.1]
		
		
		# set up message
		self.msg_map = OccupancyGrid()
		self.msg_pos_marker = Marker()
		self.msg_pos_marker.header.frame_id = "map"
		self.msg_pos_marker.ns = "navigation"
		self.msg_pos_marker.id = 0
		self.msg_pos_marker.type = Marker.CUBE
		self.msg_pos_marker.action = Marker.ADD
		self.msg_pos_marker.scale.x = 1
		self.msg_pos_marker.scale.y = 1
		self.msg_pos_marker.scale.z = 0.2
		self.msg_pos_marker.color.a = 1.0
		self.msg_pos_marker.color.r = 0.0
		self.msg_pos_marker.color.g = 1.0
		self.msg_pos_marker.color.b = 0.0
		self.msg_pos_marker.pose.orientation = Quaternion(0, 0, 0, 1)
		
		
		# Initialize member variables
		self.sim_lock = Lock()


		# Initialize Subscribers
		self.sub_map = rospy.Subscriber('/map', OccupancyGrid, self.cb_map)
		self.sub_scan = rospy.Subscriber('/scan', LaserScan, self.cb_scan)
		self.sub_move = rospy.Subscriber('/move', String, self.cb_move)
		
		#Initialize Publisher
		self.pub_pos = rospy.Publisher('/robot_pos', Point, queue_size=10)
		self.pub_pos_marker = rospy.Publisher('/visualization/robot_pos', Marker, queue_size=10)
		self.pub_map = rospy.Publisher('/robot_pos_map', OccupancyGrid, queue_size=10)
		
		
	
	def cb_map(self, data):
	# all probabilities for fields which are not reachable are zero
		self.msg_map.header = data.header
		self.msg_map.info = data.info
		
		# initialize map of uniform probabilities the first time the robot receives a message on /map topic
		if self.receive_map_data == 0:
			self.prob_pos = np.transpose(np.asarray(data.data, dtype=np.int8).reshape(data.info.width, data.info.height))
			self.prob_pos = self.prob_pos.astype('float64')
			valid_states=len(self.prob_pos[self.prob_pos == 0])
			self.prob_pos[self.prob_pos == 0]=1/valid_states
			self.prob_pos[self.prob_pos == 100] = 0
			self.prob_pos[self.prob_pos == -1] = 0
			
			self.map = np.transpose(np.asarray(data.data, dtype=np.int8).reshape(data.info.width, data.info.height))
			
			
			self.receive_map_data = 1
			
		
		
	def cb_scan(self, data):
		
		
		# int values for scan
		scan=[round(x) for x in data.ranges]
		
		directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]
		
		#wait until map received
		if self.receive_map_data == 0:
			return
		
		#iterate through rows (x)
		for x in range(np.shape(self.prob_pos)[0]):
			#iterate through collumns (y)
			for y in range(np.shape(self.prob_pos)[1]):
			
				#calculate probabilities for valid states
				if self.map[x][y] == 100 or self.map[x][y] == -1:
					continue
					
				#initialize prob
				prob=1
				
				# add probabilities for measuring scan in all 4 directions
				for u in range(len(directions)):
					
					#check if state in distance of laserscan is in grid world 20x20
					if (x+directions[u][0]*scan[u]) >= 0 and (x+directions[u][0]*scan[u]) < 20 and (y+directions[u][1]*scan[u]) >= 0 and (y+directions[u][1]*scan[u]) < 20 and((self.map[x+directions[u][0]*scan[u]][y+directions[u][1]*scan[u]] == 100) or (8 < y < 12 and (x+directions[u][0]*scan[u] == -1 or x+directions[u][0]*scan[u] == 20))):
					
						prob=prob*self.sensing_prob[0]
					
					#check if state in distance of laserscan+1 is in grid world 20x20		
					elif (x+directions[u][0]*(scan[u]+1)) >= 0 and (x+directions[u][0]*(scan[u]+1)) < 20 and (y+directions[u][1]*(scan[u]+1)) >= 0 and (y+directions[u][1]*(scan[u]+1)) < 20 and ((self.map[x+directions[u][0]*(scan[u]+1)][y+directions[u][1]*(scan[u]+1)] == 100) or (8 < y < 12 and (x+directions[u][0]*(scan[u]+1) == -1 or x+directions[u][0]*(scan[u]+1) == 20))):
						
						prob=prob*self.sensing_prob[1]
							
					
					#check if state in distance of laserscan-1 is in grid world 20x20		
					elif (x+directions[u][0]*(scan[u]-1)) >= 0 and (x+directions[u][0]*(scan[u]-1)) < 20 and (y+directions[u][1]*(scan[u]-1)) >= 0 and (y+directions[u][1]*(scan[u]-1)) < 20 and ((self.map[x+directions[u][0]*(scan[u]-1)][y+directions[u][1]*(scan[u]-1)] == 100) or (8 < y < 12 and (x+directions[u][0]*(scan[u]-1) == -1 or x+directions[u][0]*(scan[u]-1) == 20))):
						
						prob=prob*self.sensing_prob[1]
							
					else:
						prob=prob*0.001
							
				#update map
				self.prob_pos[x][y]=prob
				
		#normalize probabilities
		self.prob_pos /= sum(sum(self.prob_pos))
				
	
	
	def cb_move(self, data):
		
		if self.receive_map_data == 0:
			return
		
		#get move and calculate prediction by recalculating probabilities for all 400 cells in grid
		direction = str(data)
		N = String()
		E = String()
		S = String()
		W = String()
		N.data= "N"
		E.data= "E"
		S.data= "S"
		W.data= "W"
		
		prob_map=np.copy(self.prob_pos)
		
		
		if data == N:
			a_00 = (0, 1)
			a_minus_90 = (-1, 0)
		elif data == E:
			a_00 = (1, 0)
			a_minus_90 = (0, 1)
		elif data == S:
			a_00 = (0, -1)
			a_minus_90 = (1, 0)
		elif data == W:
			a_00 = (-1, 0)
			a_minus_90 = (0, -1)
		
		
		#iterate throuh rows
		for x in range(np.shape(self.prob_pos)[0]):
			#iterate throuh collumns
			for y in range(np.shape(self.prob_pos)[1]):
				#check if state is a valid state
				if self.map[x][y] == 100 or self.map[x][y] == -1:
					continue

				
				prob=0
				
				
				#add probabilities for all 5 possible previous states * corresponding transition probability
				
				#coming from state_t-1 to state t in move direction
				if (x-a_00[0]) >= 0 and (x-a_00[0]) < 20 and (y-a_00[1]) >= 0 and (y-a_00[1]) < 20 and self.map[x-a_00[0]][y-a_00[1]] == 0:
					prob=prob+self.action_prob[0]*self.prob_pos[x-a_00[0]][y-a_00[1]]
					 
				#coming from state_t-1 to state t in move direction -90
				if (x-a_minus_90[0]) >= 0 and (x-a_minus_90[0]) < 20 and (y-a_minus_90[1]) >= 0 and (y-a_minus_90[1]) < 20 and self.map[x-a_minus_90[0]][y-a_minus_90[1]] == 0:
					prob=prob+self.action_prob[1]*self.prob_pos[x-a_minus_90[0]][y-a_minus_90[1]]

				#coming from state_t-1 to state t in move direction +90
				if (x+a_minus_90[0]) >= 0 and (x+a_minus_90[0]) < 20 and (y+a_minus_90[1]) >= 0 and (y+a_minus_90[1]) < 20 and self.map[x+a_minus_90[0]][y+a_minus_90[1]] == 0:
					prob=prob+self.action_prob[2]*self.prob_pos[x+a_minus_90[0]][y+a_minus_90[1]]
					 			 
				#coming from state_t-1 to state t in move direction +180
				if (x+a_00[0]) >= 0 and (x+a_00[0]) < 20 and (y+a_00[1]) >= 0 and (y+a_00[1]) < 20 and self.map[x+a_00[0]][y+a_00[1]] == 0:
					prob=prob+self.action_prob[3]*self.prob_pos[x+a_00[0]][y+a_00[1]]
					 
				#stay in position
				prob=prob+self.action_prob[4]*self.prob_pos[x][y]
				
				#update map of probabily for this timestep without changing probabilities which are still used in this time step
				prob_map[x][y] = prob
			
		#update map of probability	
		self.prob_pos=np.copy(prob_map)

		
	
	def publish(self):
		if self.receive_map_data == 1:
			
	
			#calcluate most likely position
			max_prob = np.where(self.prob_pos == self.prob_pos.max())

			
			if self.last_pos is not None:
				#self.last_pos = np.where(max_prob == sum(max_prob-self.last_pos).min())
				pick = 10000
				for i in range(np.shape(max_prob)[1]):
					if (max_prob[0][i]-self.last_pos[0] + max_prob[1][i]-self.last_pos[1]) <= pick:
						pick = i
				
					
			else:
				pick = random.choice(range(len(max_prob[1])))
				
			x_pos = max_prob[0][pick]
			y_pos = max_prob[1][pick]
			self.last_pos = np.array([x_pos, y_pos])
			self.pos = np.array([x_pos, y_pos])
			
			
			#publish position
			point = Point()
			point.x=self.pos[0]
			point.y=self.pos[1]
			point.z=0
			self.pub_pos.publish(point)
			
			#publish Marker
			self.msg_pos_marker.pose.position.x = self.pos[0]+0.5
			self.msg_pos_marker.pose.position.y = self.pos[1]+0.5
			self.pub_pos_marker.publish(self.msg_pos_marker)
				
			#publish map
			prob_pos_print = np.transpose(self.prob_pos)
			prob_pos_print = prob_pos_print*100
			prob_pos_print = prob_pos_print.astype(int)
			self.msg_map.data = tuple(prob_pos_print.ravel())
			self.pub_map.publish(self.msg_map)
			

		
	def run(self):
		rate = rospy.Rate(1)
		while not rospy.is_shutdown():
			#keeps node from exiting until the node has been shutdown.
			self.publish()
			rate.sleep()

	
if __name__ == "__main__":
    rospy.init_node('localization_node')
    localization_node = Localization_Node()
    localization_node.run()

